// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/paralin/raft-grpc/raft-grpc.proto

/*
Package raftgrpc is a generated protocol buffer package.

It is generated from these files:
	github.com/paralin/raft-grpc/raft-grpc.proto

It has these top-level messages:
	LogEntry
	PeerNameContainer
	AppendEntriesRequest
	AppendEntriesResponse
	RequestVoteRequest
	RequestVoteResponse
	InstallSnapshotRequest
	InstallSnapshotResponse
	AppendEntriesPipelineResponse
*/
package raftgrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// LogEntryType is the type of the LogEntry
type LogEntryType int32

const (
	LogEntryType_LOG_ENTRY_COMMAND     LogEntryType = 0
	LogEntryType_LOG_ENTRY_NOOP        LogEntryType = 1
	LogEntryType_LOG_ENTRY_ADD_PEER    LogEntryType = 2
	LogEntryType_LOG_ENTRY_REMOVE_PEER LogEntryType = 3
	LogEntryType_LOG_ENTRY_BARRIER     LogEntryType = 4
)

var LogEntryType_name = map[int32]string{
	0: "LOG_ENTRY_COMMAND",
	1: "LOG_ENTRY_NOOP",
	2: "LOG_ENTRY_ADD_PEER",
	3: "LOG_ENTRY_REMOVE_PEER",
	4: "LOG_ENTRY_BARRIER",
}
var LogEntryType_value = map[string]int32{
	"LOG_ENTRY_COMMAND":     0,
	"LOG_ENTRY_NOOP":        1,
	"LOG_ENTRY_ADD_PEER":    2,
	"LOG_ENTRY_REMOVE_PEER": 3,
	"LOG_ENTRY_BARRIER":     4,
}

func (x LogEntryType) String() string {
	return proto.EnumName(LogEntryType_name, int32(x))
}
func (LogEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// LogEntry contains a raft log entry.
type LogEntry struct {
	// Index holds the index of the log entry.
	Index uint64 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	// Term holds the election term of the log entry.
	Term uint64 `protobuf:"varint,2,opt,name=term" json:"term,omitempty"`
	// Type holds the type of the log entry.
	Type LogEntryType `protobuf:"varint,3,opt,name=type,enum=raftgrpc.LogEntryType" json:"type,omitempty"`
	// Data holds the log entry's type-specific data.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *LogEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LogEntry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *LogEntry) GetType() LogEntryType {
	if m != nil {
		return m.Type
	}
	return LogEntryType_LOG_ENTRY_COMMAND
}

func (m *LogEntry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// PeerNameContainer encodes a peer name to bytes.
type PeerNameContainer struct {
	// PeerName is the peer name in the container.
	PeerName string `protobuf:"bytes,1,opt,name=peer_name,json=peerName" json:"peer_name,omitempty"`
}

func (m *PeerNameContainer) Reset()                    { *m = PeerNameContainer{} }
func (m *PeerNameContainer) String() string            { return proto.CompactTextString(m) }
func (*PeerNameContainer) ProtoMessage()               {}
func (*PeerNameContainer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PeerNameContainer) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

// AppendEntriesRequest maps to the raft AppendEntriesRequest.
type AppendEntriesRequest struct {
	// Term is the current election term.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// Leader is the current leader id.
	Leader []byte `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	// PrevLogEntry is the previous log entry.
	PrevLogEntry uint64 `protobuf:"varint,3,opt,name=prev_log_entry,json=prevLogEntry" json:"prev_log_entry,omitempty"`
	// PrevLogTerm is the previous log term.
	PrevLogTerm uint64 `protobuf:"varint,4,opt,name=prev_log_term,json=prevLogTerm" json:"prev_log_term,omitempty"`
	// Entries are the new log entries to commit.
	Entries []*LogEntry `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	// LeaderCommitIndex is the commit index on the leader.
	LeaderCommitIndex uint64 `protobuf:"varint,6,opt,name=leader_commit_index,json=leaderCommitIndex" json:"leader_commit_index,omitempty"`
}

func (m *AppendEntriesRequest) Reset()                    { *m = AppendEntriesRequest{} }
func (m *AppendEntriesRequest) String() string            { return proto.CompactTextString(m) }
func (*AppendEntriesRequest) ProtoMessage()               {}
func (*AppendEntriesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AppendEntriesRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesRequest) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *AppendEntriesRequest) GetPrevLogEntry() uint64 {
	if m != nil {
		return m.PrevLogEntry
	}
	return 0
}

func (m *AppendEntriesRequest) GetPrevLogTerm() uint64 {
	if m != nil {
		return m.PrevLogTerm
	}
	return 0
}

func (m *AppendEntriesRequest) GetEntries() []*LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *AppendEntriesRequest) GetLeaderCommitIndex() uint64 {
	if m != nil {
		return m.LeaderCommitIndex
	}
	return 0
}

// AppendEntriesResponse is the response to the appendentries request.
type AppendEntriesResponse struct {
	// Term is the newer term if the leader is out of date.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// LastLog is a hint to help accelerate rebuilding slow nodes.
	LastLog uint64 `protobuf:"varint,2,opt,name=last_log,json=lastLog" json:"last_log,omitempty"`
	// Success will be false if we have a conflicting entry.
	Success bool `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	// NoRetryBackoff indicates we don't need to backoff the next attempt.
	NoRetryBackoff bool `protobuf:"varint,4,opt,name=no_retry_backoff,json=noRetryBackoff" json:"no_retry_backoff,omitempty"`
}

func (m *AppendEntriesResponse) Reset()                    { *m = AppendEntriesResponse{} }
func (m *AppendEntriesResponse) String() string            { return proto.CompactTextString(m) }
func (*AppendEntriesResponse) ProtoMessage()               {}
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AppendEntriesResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesResponse) GetLastLog() uint64 {
	if m != nil {
		return m.LastLog
	}
	return 0
}

func (m *AppendEntriesResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AppendEntriesResponse) GetNoRetryBackoff() bool {
	if m != nil {
		return m.NoRetryBackoff
	}
	return false
}

// RequestVoteRequest is the command used by a candidate to ask a Raft peer for a vote in an election.
type RequestVoteRequest struct {
	// Term is the new voting term.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// Candidate is the candidate id
	Candidate []byte `protobuf:"bytes,2,opt,name=candidate,proto3" json:"candidate,omitempty"`
	// LastLogIndex is the last log index.
	LastLogIndex uint64 `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex" json:"last_log_index,omitempty"`
	// LastLogTerm is the last log term.
	LastLogTerm uint64 `protobuf:"varint,4,opt,name=last_log_term,json=lastLogTerm" json:"last_log_term,omitempty"`
}

func (m *RequestVoteRequest) Reset()                    { *m = RequestVoteRequest{} }
func (m *RequestVoteRequest) String() string            { return proto.CompactTextString(m) }
func (*RequestVoteRequest) ProtoMessage()               {}
func (*RequestVoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RequestVoteRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVoteRequest) GetCandidate() []byte {
	if m != nil {
		return m.Candidate
	}
	return nil
}

func (m *RequestVoteRequest) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *RequestVoteRequest) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

// RequestVoteResponse is the response returned from a RequestVoteRequest.
type RequestVoteResponse struct {
	// Term is the newer term if the lader is out of date.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// Peers contains the current peers list so a node can shutdown on removal.
	Peers []byte `protobuf:"bytes,2,opt,name=peers,proto3" json:"peers,omitempty"`
	// Granted if the vote was granted.
	Granted bool `protobuf:"varint,3,opt,name=granted" json:"granted,omitempty"`
}

func (m *RequestVoteResponse) Reset()                    { *m = RequestVoteResponse{} }
func (m *RequestVoteResponse) String() string            { return proto.CompactTextString(m) }
func (*RequestVoteResponse) ProtoMessage()               {}
func (*RequestVoteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RequestVoteResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVoteResponse) GetPeers() []byte {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *RequestVoteResponse) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

// InstallSnapshotRequest is the command sent to a Raft peer to bootstrap its log (and state machine) from a snapshot on another peer.
type InstallSnapshotRequest struct {
	// Term is the current term.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// Leader is the current leader.
	Leader []byte `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	// LastLogIndex is the last log index included in the snapshot.
	LastLogIndex uint64 `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex" json:"last_log_index,omitempty"`
	// LastLogTerm is the last log term included in the snapshot.
	LastLogTerm uint64 `protobuf:"varint,4,opt,name=last_log_term,json=lastLogTerm" json:"last_log_term,omitempty"`
	// Peers is the peer set in the snapshot
	Peers []byte `protobuf:"bytes,5,opt,name=peers,proto3" json:"peers,omitempty"`
	// Snapshot is the body of the snapshot.
	Snapshot []byte `protobuf:"bytes,6,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *InstallSnapshotRequest) Reset()                    { *m = InstallSnapshotRequest{} }
func (m *InstallSnapshotRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallSnapshotRequest) ProtoMessage()               {}
func (*InstallSnapshotRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InstallSnapshotRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshotRequest) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *InstallSnapshotRequest) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *InstallSnapshotRequest) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

func (m *InstallSnapshotRequest) GetPeers() []byte {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *InstallSnapshotRequest) GetSnapshot() []byte {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// InstallSnapshotResponse is the response to the InstallSnapshot call.
type InstallSnapshotResponse struct {
	// Term is the term in the snapshot.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// Success indiciates if the snapshot was installed properly.
	Success bool `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
}

func (m *InstallSnapshotResponse) Reset()                    { *m = InstallSnapshotResponse{} }
func (m *InstallSnapshotResponse) String() string            { return proto.CompactTextString(m) }
func (*InstallSnapshotResponse) ProtoMessage()               {}
func (*InstallSnapshotResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *InstallSnapshotResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshotResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// AppendEntriesPipelineResponse is the wrapper of an AmendEntriesResponse in a pipeline.
type AppendEntriesPipelineResponse struct {
	// Error is any potential error.
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// Response is the response object if necessary
	Response *AppendEntriesResponse `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
}

func (m *AppendEntriesPipelineResponse) Reset()                    { *m = AppendEntriesPipelineResponse{} }
func (m *AppendEntriesPipelineResponse) String() string            { return proto.CompactTextString(m) }
func (*AppendEntriesPipelineResponse) ProtoMessage()               {}
func (*AppendEntriesPipelineResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AppendEntriesPipelineResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *AppendEntriesPipelineResponse) GetResponse() *AppendEntriesResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*LogEntry)(nil), "raftgrpc.LogEntry")
	proto.RegisterType((*PeerNameContainer)(nil), "raftgrpc.PeerNameContainer")
	proto.RegisterType((*AppendEntriesRequest)(nil), "raftgrpc.AppendEntriesRequest")
	proto.RegisterType((*AppendEntriesResponse)(nil), "raftgrpc.AppendEntriesResponse")
	proto.RegisterType((*RequestVoteRequest)(nil), "raftgrpc.RequestVoteRequest")
	proto.RegisterType((*RequestVoteResponse)(nil), "raftgrpc.RequestVoteResponse")
	proto.RegisterType((*InstallSnapshotRequest)(nil), "raftgrpc.InstallSnapshotRequest")
	proto.RegisterType((*InstallSnapshotResponse)(nil), "raftgrpc.InstallSnapshotResponse")
	proto.RegisterType((*AppendEntriesPipelineResponse)(nil), "raftgrpc.AppendEntriesPipelineResponse")
	proto.RegisterEnum("raftgrpc.LogEntryType", LogEntryType_name, LogEntryType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftService service

type RaftServiceClient interface {
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (RaftService_AppendEntriesPipelineClient, error)
	// AppendEntries performs a single append entries request / response.
	AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a vote in an election.
	RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log (and state machine) from a snapshot on another peer.
	InstallSnapshot(ctx context.Context, in *InstallSnapshotRequest, opts ...grpc.CallOption) (*InstallSnapshotResponse, error)
}

type raftServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftServiceClient(cc *grpc.ClientConn) RaftServiceClient {
	return &raftServiceClient{cc}
}

func (c *raftServiceClient) AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (RaftService_AppendEntriesPipelineClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RaftService_serviceDesc.Streams[0], c.cc, "/raftgrpc.RaftService/AppendEntriesPipeline", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftServiceAppendEntriesPipelineClient{stream}
	return x, nil
}

type RaftService_AppendEntriesPipelineClient interface {
	Send(*AppendEntriesRequest) error
	Recv() (*AppendEntriesPipelineResponse, error)
	grpc.ClientStream
}

type raftServiceAppendEntriesPipelineClient struct {
	grpc.ClientStream
}

func (x *raftServiceAppendEntriesPipelineClient) Send(m *AppendEntriesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftServiceAppendEntriesPipelineClient) Recv() (*AppendEntriesPipelineResponse, error) {
	m := new(AppendEntriesPipelineResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftServiceClient) AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error) {
	out := new(AppendEntriesResponse)
	err := grpc.Invoke(ctx, "/raftgrpc.RaftService/AppendEntries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error) {
	out := new(RequestVoteResponse)
	err := grpc.Invoke(ctx, "/raftgrpc.RaftService/RequestVote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) InstallSnapshot(ctx context.Context, in *InstallSnapshotRequest, opts ...grpc.CallOption) (*InstallSnapshotResponse, error) {
	out := new(InstallSnapshotResponse)
	err := grpc.Invoke(ctx, "/raftgrpc.RaftService/InstallSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RaftService service

type RaftServiceServer interface {
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(RaftService_AppendEntriesPipelineServer) error
	// AppendEntries performs a single append entries request / response.
	AppendEntries(context.Context, *AppendEntriesRequest) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a vote in an election.
	RequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log (and state machine) from a snapshot on another peer.
	InstallSnapshot(context.Context, *InstallSnapshotRequest) (*InstallSnapshotResponse, error)
}

func RegisterRaftServiceServer(s *grpc.Server, srv RaftServiceServer) {
	s.RegisterService(&_RaftService_serviceDesc, srv)
}

func _RaftService_AppendEntriesPipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServiceServer).AppendEntriesPipeline(&raftServiceAppendEntriesPipelineServer{stream})
}

type RaftService_AppendEntriesPipelineServer interface {
	Send(*AppendEntriesPipelineResponse) error
	Recv() (*AppendEntriesRequest, error)
	grpc.ServerStream
}

type raftServiceAppendEntriesPipelineServer struct {
	grpc.ServerStream
}

func (x *raftServiceAppendEntriesPipelineServer) Send(m *AppendEntriesPipelineResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftServiceAppendEntriesPipelineServer) Recv() (*AppendEntriesRequest, error) {
	m := new(AppendEntriesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftService_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftgrpc.RaftService/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).AppendEntries(ctx, req.(*AppendEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftgrpc.RaftService/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).RequestVote(ctx, req.(*RequestVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_InstallSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).InstallSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raftgrpc.RaftService/InstallSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).InstallSnapshot(ctx, req.(*InstallSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "raftgrpc.RaftService",
	HandlerType: (*RaftServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntries",
			Handler:    _RaftService_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _RaftService_RequestVote_Handler,
		},
		{
			MethodName: "InstallSnapshot",
			Handler:    _RaftService_InstallSnapshot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AppendEntriesPipeline",
			Handler:       _RaftService_AppendEntriesPipeline_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/paralin/raft-grpc/raft-grpc.proto",
}

func init() { proto.RegisterFile("github.com/paralin/raft-grpc/raft-grpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x51, 0x4f, 0x1a, 0x4b,
	0x14, 0x76, 0x11, 0x74, 0x3d, 0x20, 0x17, 0x47, 0xe4, 0x22, 0x57, 0xef, 0xe5, 0x6e, 0x6e, 0x72,
	0x89, 0xb1, 0x68, 0xe8, 0x63, 0x9f, 0x50, 0x89, 0x31, 0x41, 0x20, 0xa3, 0x31, 0xf5, 0x69, 0x33,
	0x2e, 0x07, 0xdc, 0x14, 0x76, 0xb7, 0xb3, 0xa3, 0x29, 0xcf, 0x7d, 0xeb, 0x53, 0x7f, 0x52, 0x7f,
	0x4f, 0xdf, 0xfa, 0x0f, 0x9a, 0x99, 0x9d, 0x65, 0x01, 0x15, 0x93, 0xa6, 0x6f, 0x73, 0xce, 0x7c,
	0xf3, 0xf1, 0x7d, 0x1f, 0xe7, 0x00, 0x1c, 0x0e, 0x5d, 0x71, 0xff, 0x70, 0x57, 0x77, 0xfc, 0xf1,
	0x51, 0xc0, 0x38, 0x1b, 0xb9, 0xde, 0x11, 0x67, 0x03, 0xf1, 0x66, 0xc8, 0x03, 0x27, 0x39, 0xd5,
	0x03, 0xee, 0x0b, 0x9f, 0x98, 0xb2, 0x21, 0x6b, 0x4b, 0x80, 0xd9, 0xf6, 0x87, 0x2d, 0x4f, 0xf0,
	0x09, 0x29, 0x42, 0xc6, 0xf5, 0xfa, 0xf8, 0xa9, 0x6c, 0x54, 0x8d, 0x5a, 0x9a, 0x46, 0x05, 0x21,
	0x90, 0x16, 0xc8, 0xc7, 0xe5, 0x94, 0x6a, 0xaa, 0x33, 0x39, 0x80, 0xb4, 0x98, 0x04, 0x58, 0x5e,
	0xad, 0x1a, 0xb5, 0x7c, 0xa3, 0x54, 0x8f, 0xe9, 0xea, 0x31, 0xd7, 0xf5, 0x24, 0x40, 0xaa, 0x30,
	0xf2, 0x7d, 0x9f, 0x09, 0x56, 0x4e, 0x57, 0x8d, 0x5a, 0x8e, 0xaa, 0xb3, 0x75, 0x0c, 0x5b, 0x3d,
	0x44, 0xde, 0x61, 0x63, 0x3c, 0xf5, 0x3d, 0xc1, 0x5c, 0x0f, 0x39, 0xf9, 0x0b, 0x36, 0x02, 0x44,
	0x6e, 0x7b, 0x6c, 0x8c, 0x4a, 0xc2, 0x06, 0x35, 0x03, 0x8d, 0xb2, 0xbe, 0x1b, 0x50, 0x6c, 0x06,
	0x01, 0x7a, 0x7d, 0xc9, 0xef, 0x62, 0x48, 0xf1, 0xe3, 0x03, 0x86, 0x62, 0x2a, 0xcf, 0x98, 0x91,
	0x57, 0x82, 0xb5, 0x11, 0xb2, 0x3e, 0x72, 0x25, 0x3a, 0x47, 0x75, 0x45, 0xfe, 0x83, 0x7c, 0xc0,
	0xf1, 0xd1, 0x1e, 0xf9, 0x43, 0x1b, 0xa5, 0x4c, 0x65, 0x20, 0x4d, 0x73, 0xb2, 0x3b, 0x8d, 0xc1,
	0x82, 0xcd, 0x29, 0x4a, 0x51, 0xa7, 0x15, 0x28, 0xab, 0x41, 0xd7, 0xf2, 0x13, 0x0e, 0x61, 0x1d,
	0x23, 0x1d, 0xe5, 0x4c, 0x75, 0xb5, 0x96, 0x6d, 0x90, 0xa7, 0x19, 0xd0, 0x18, 0x42, 0xea, 0xb0,
	0x1d, 0x29, 0xb0, 0x1d, 0x7f, 0x3c, 0x76, 0x85, 0x1d, 0xc5, 0xbc, 0xa6, 0x78, 0xb7, 0xa2, 0xab,
	0x53, 0x75, 0x73, 0x21, 0x2f, 0xac, 0x2f, 0x06, 0xec, 0x2c, 0x98, 0x0d, 0x03, 0xdf, 0x0b, 0xf1,
	0x59, 0xb7, 0xbb, 0x60, 0x8e, 0x58, 0x28, 0xa4, 0x5e, 0xfd, 0x25, 0xad, 0xcb, 0xba, 0xed, 0x0f,
	0x49, 0x19, 0xd6, 0xc3, 0x07, 0xc7, 0xc1, 0x30, 0x54, 0x4e, 0x4d, 0x1a, 0x97, 0xa4, 0x06, 0x05,
	0xcf, 0xb7, 0x39, 0x0a, 0x3e, 0xb1, 0xef, 0x98, 0xf3, 0xc1, 0x1f, 0x0c, 0x94, 0x4f, 0x93, 0xe6,
	0x3d, 0x9f, 0xca, 0xf6, 0x49, 0xd4, 0xb5, 0xbe, 0x1a, 0x40, 0x74, 0xd8, 0x37, 0xbe, 0xc0, 0x65,
	0xb9, 0xef, 0xc1, 0x86, 0xc3, 0xbc, 0xbe, 0xdb, 0x67, 0x02, 0x75, 0xf4, 0x49, 0x43, 0xa6, 0x1f,
	0xeb, 0xd4, 0x01, 0xe8, 0xf4, 0xb5, 0x5a, 0xe5, 0x5d, 0xa6, 0x3f, 0x45, 0xcd, 0xa6, 0xaf, 0x41,
	0x32, 0x7d, 0xeb, 0x16, 0xb6, 0xe7, 0x14, 0x2d, 0x09, 0xa7, 0x08, 0x19, 0x39, 0x43, 0xa1, 0x96,
	0x13, 0x15, 0x32, 0x97, 0x21, 0x67, 0x9e, 0xc0, 0x7e, 0x9c, 0x8b, 0x2e, 0xad, 0x6f, 0x06, 0x94,
	0x2e, 0xbc, 0x50, 0xb0, 0xd1, 0xe8, 0xca, 0x63, 0x41, 0x78, 0xef, 0x8b, 0x5f, 0x9c, 0xb4, 0xdf,
	0xe3, 0x35, 0x31, 0x90, 0x99, 0x35, 0x50, 0x01, 0x33, 0xd4, 0xf2, 0xd4, 0x18, 0xe5, 0xe8, 0xb4,
	0xb6, 0xce, 0xe1, 0xcf, 0x27, 0x0e, 0x96, 0x24, 0x34, 0x33, 0x23, 0xa9, 0xb9, 0x19, 0xb1, 0x38,
	0xec, 0xcf, 0x4d, 0x61, 0xcf, 0x0d, 0x70, 0xe4, 0x7a, 0x49, 0xe0, 0x45, 0xc8, 0x20, 0xe7, 0x3e,
	0xd7, 0xdb, 0x1a, 0x15, 0xe4, 0x1d, 0x98, 0x5c, 0x23, 0x14, 0x63, 0xb6, 0xf1, 0x4f, 0xb2, 0x1c,
	0xcf, 0x8e, 0x35, 0x9d, 0x3e, 0x38, 0xf8, 0x6c, 0x40, 0x6e, 0xf6, 0x47, 0x84, 0xec, 0xc0, 0x56,
	0xbb, 0x7b, 0x6e, 0xb7, 0x3a, 0xd7, 0xf4, 0xd6, 0x3e, 0xed, 0x5e, 0x5e, 0x36, 0x3b, 0x67, 0x85,
	0x15, 0x42, 0x20, 0x9f, 0xb4, 0x3b, 0xdd, 0x6e, 0xaf, 0x60, 0x90, 0x12, 0x90, 0xa4, 0xd7, 0x3c,
	0x3b, 0xb3, 0x7b, 0xad, 0x16, 0x2d, 0xa4, 0xc8, 0x2e, 0xec, 0x24, 0x7d, 0xda, 0xba, 0xec, 0xde,
	0xb4, 0xa2, 0xab, 0xd5, 0x79, 0xf6, 0x93, 0x26, 0xa5, 0x17, 0x2d, 0x5a, 0x48, 0x37, 0x7e, 0xa4,
	0x20, 0x4b, 0xd9, 0x40, 0x5c, 0x21, 0x7f, 0x74, 0x1d, 0x24, 0x83, 0x85, 0x7d, 0x8c, 0x93, 0x20,
	0x7f, 0xbf, 0xe8, 0x4c, 0xcd, 0x4c, 0xe5, 0xff, 0x17, 0xee, 0x17, 0xa3, 0xb4, 0x56, 0x6a, 0xc6,
	0xb1, 0x41, 0x28, 0x6c, 0xce, 0xc1, 0x5e, 0xe5, 0x7f, 0x2d, 0x59, 0x6b, 0x85, 0xb4, 0x21, 0x3b,
	0xb3, 0x2c, 0x64, 0x2f, 0x79, 0xf1, 0x74, 0xab, 0x2b, 0xfb, 0x2f, 0xdc, 0x4e, 0xd9, 0xde, 0xc3,
	0x1f, 0x0b, 0xc3, 0x45, 0xaa, 0xc9, 0x9b, 0xe7, 0x37, 0xa7, 0xf2, 0xef, 0x12, 0x44, 0xcc, 0x7c,
	0xb7, 0xa6, 0xfe, 0x9a, 0xde, 0xfe, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x5c, 0xee, 0xb5, 0x48, 0xca,
	0x06, 0x00, 0x00,
}
